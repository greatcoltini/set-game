<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Online SET Game</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    #gameBoard {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin: 20px 0;
    }
    .card {
      border: 1px solid #ccc;
      padding: 10px;
      text-align: center;
      cursor: pointer;
      user-select: none;
    }
    .selected {
      border-color: red;
    }
    #players {
      margin-bottom: 15px;
    }
    #joinScreen, #gameScreen {
      max-width: 600px;
      margin: auto;
    }


    /* Container to hold sidebar and main content */
    #container {
      display: flex;
      align-items: flex-start;
    }

    /* Sidebar styling */
    #sidebar {
      width: 250px;
      margin-right: 20px;
    }

    /* Players section styling */
    #players {
      margin-bottom: 20px;
    }

    /* Chat interface styling */
    #chat {
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 5px;
    }

    #chatMessages {
      height: 200px;
      overflow-y: auto;
      border-bottom: 1px solid #ccc;
      margin-bottom: 10px;
    }

    #chatInput {
      width: calc(100% - 60px);
      margin-right: 10px;
    }

    #sendChatBtn {
      width: 50px;
    }

    /* Main content styling */
    #mainContent {
      flex-grow: 1;
    }

  </style>
</head>
<body>

    <!-- Join Screen -->
    <div id="joinScreen">
      <h2>Join Game</h2>
      <input type="text" id="playerName" placeholder="Enter your name">
      <button id="joinBtn">Join Game</button>
      <div id="joinError" style="color: red;"></div>
    </div>

    <div id="container">
      <!-- Sidebar for Players and Chat -->
      <div id="sidebar">
        <div id="players">
          <h3>Players</h3>
          <!-- Player list will be populated here -->
        </div>
        <div id="chat">
          <h3>Chat</h3>
          <div id="chatMessages">
            <!-- Chat messages will appear here -->
          </div>
          <input type="text" id="chatInput" placeholder="Type a message...">
          <button id="sendChatBtn">Send</button>
        </div>
    </div>

    <!-- Main Content -->
    <div id="mainContent">
      <!-- Existing game content -->
      <h2>Online SET Game</h2>
      <div id="gameBoard"></div>
      <div id="deckCount">Cards Remaining: 0</div>
      <div id="message"></div>
      <!-- Admin Controls -->
      <div id="adminControls" style="margin-top: 20px;">
        <button id="resetGameBtn">Reset Game</button>
      </div>
    </div>
  </div>


  <!-- Firebase (using compat libraries for simplicity) -->
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-database-compat.js"></script>
  <script>
    // TODO: Replace the following with your Firebase project configuration.
	  const firebaseConfig = {
		apiKey: "AIzaSyDSQvcXXw-pQBuiLZAsfHD8yWDF4c34pYU",
		authDomain: "set-test-game.firebaseapp.com",
		projectId: "set-test-game",
		storageBucket: "set-test-game.firebasestorage.app",
		messagingSenderId: "992674610545",
		appId: "1:992674610545:web:4317734688a5b7cc8d4ad0",
		measurementId: "G-8KEBPK2RSW"
	  };
    firebase.initializeApp(firebaseConfig);
    var database = firebase.database();

    // Global variables
    var playerId = null;
    var selectedCards = [];

    // Utility functions for the SET game
    function createDeck() {
      const deck = [];
      const shapes   = ['oval', 'squiggle', 'diamond'];
      const colors   = ['red', 'green', 'purple'];
      const shadings = ['solid', 'striped', 'open'];
      const numbers  = [1, 2, 3];
      for (let s of shapes) {
        for (let c of colors) {
          for (let sh of shadings) {
            for (let n of numbers) {
              deck.push({ shape: s, color: c, shading: sh, number: n });
            }
          }
        }
      }
      return deck;
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // Check if three cards form a valid SET
    function isSet(cards) {
      if (cards.length !== 3) return false;
      const attributes = ['shape', 'color', 'shading', 'number'];
      return attributes.every(attr => {
        const values = cards.map(card => card[attr]);
        return (values[0] === values[1] && values[1] === values[2]) ||
               (new Set(values).size === 3);
      });
    }

    // Function to check if there is at least one valid set on the board
    function hasValidSet(board) {
      for (let i = 0; i < board.length; i++) {
        for (let j = i + 1; j < board.length; j++) {
          for (let k = j + 1; k < board.length; k++) {
            if (isSet([board[i], board[j], board[k]])) {
              return true;
            }
          }
        }
      }
      return false;
    }

    // Function to ensure there is a valid set on the board
    function ensureValidSet() {
      database.ref('game').once('value').then(function(snapshot) {
        const game = snapshot.val();
        if (!game) return;
        let { board, deck } = game;

        // Keep adding cards until a valid set is found or the deck is empty
        while (!hasValidSet(board) && deck.length > 0) {
          board.push(deck.shift());
        }

        database.ref('game').update({ board, deck });
      });
    }

    // Initialize game state if it doesn't exist
    // Modify the game state initialization to ensure a valid set is present
    function initGameState() {
      database.ref('game').once('value', function(snapshot) {
        if (!snapshot.exists()) {
          const deck = shuffle(createDeck());
          const board = deck.splice(0, 12);
          database.ref('game').set({
            deck: deck,
            board: board,
            lastMove: null
          }).then(() => ensureValidSet()); // Ensure a valid set exists
        }
      });
    }
    initGameState();

    // Listen for game state changes to update the board
    database.ref('game').on('value', function(snapshot) {
      const game = snapshot.val();
      if (game) {
        updateBoard(game.board);
      }
    });

    // Listen for players list changes
    database.ref('players').on('value', function(snapshot) {
      const players = snapshot.val() || {};
      updatePlayersList(players);
    });

    // Update the players list UI
    function updatePlayersList(players) {
      const playersDiv = document.getElementById('players');
      playersDiv.innerHTML = '<h3>Players</h3>';
      for (let id in players) {
        playersDiv.innerHTML += '<div>' + players[id].name + ': ' + players[id].score + '</div>';
      }
    }

    // Render the board
    function updateBoard(board) {
      const boardDiv = document.getElementById('gameBoard');
      boardDiv.innerHTML = '';
      board.forEach((card, index) => {
        const cardDiv = document.createElement('div');
        cardDiv.className = 'card';
        cardDiv.dataset.index = index;

        // Construct the image filename based on card attributes
        const imageName = `${card.shape}_${card.color}_${card.shading}_${card.number}.png`;
        const imagePath = `images/cards/${imageName}`;

        // Create the image element
        const cardImage = document.createElement('img');
        cardImage.src = imagePath;
        cardImage.alt = `${card.number} ${card.shading} ${card.color} ${card.shape}`;
        cardImage.style.width = '100%';

        // Append the image to the card div
        cardDiv.appendChild(cardImage);

        // Add click event listener
        cardDiv.addEventListener('click', function() {
          handleCardClick(index, cardDiv, card);
        });

        // Append the card div to the board
        boardDiv.appendChild(cardDiv);
      });

        // Update deck count
      database.ref('game/deck').once('value', function (snapshot) {
        document.getElementById('deckCount').innerText = `Cards Remaining: ${snapshot.val()?.length || 0}`;
      });
    }

    // After each move, check if a valid set exists
    function handleCardClick(index, cardDiv, card) {
      if (cardDiv.classList.contains('selected')) {
        cardDiv.classList.remove('selected');
        selectedCards = selectedCards.filter(c => c.index !== index);
      } else {
        cardDiv.classList.add('selected');
        selectedCards.push({ index, card });
        if (selectedCards.length === 3) {
          if (isSet(selectedCards.map(item => item.card))) {
            database.ref('game').once('value').then(function(snapshot) {
              const game = snapshot.val();
              const newBoard = game.board.slice();
              selectedCards.sort((a, b) => b.index - a.index);
              selectedCards.forEach(selection => {
                if (game.deck.length > 0) {
                  newBoard[selection.index] = game.deck.shift();
                } else {
                  newBoard.splice(selection.index, 1);
                }
              });
              database.ref('game').update({
                board: newBoard,
                deck: game.deck,
                lastMove: { player: playerId, time: Date.now() }
              }).then(() => ensureValidSet()); // Ensure a valid set exists after update
              
              database.ref('players/' + playerId).transaction(function(player) {
                if (player) {
                  player.score = (player.score || 0) + 1;
                }
                return player;
              });
              clearSelection();
            });
          } else {
            document.getElementById('message').innerText = 'Not a valid set!';
            setTimeout(function() {
              document.getElementById('message').innerText = '';
              clearSelection();
            }, 1000);
          }
        }
      }
    }


    // Clear card selection UI
    function clearSelection() {
      selectedCards = [];
      document.querySelectorAll('.card.selected').forEach(function(card) {
        card.classList.remove('selected');
      });
    }

    // Reference to the game and players in the database
    const gameRef = database.ref('game');
    const playersRef = database.ref('players');

    // Function to reset the game state
    function resetGame() {
      // Confirm before resetting
      if (confirm('Are you sure you want to reset the game? This will clear all game data and player information.')) {
        // Clear the game state
        gameRef.set(null)
          .then(() => {
            console.log('Game state cleared successfully.');
            // Reinitialize the game state
            initGameState();
          })
          .catch(error => {
            console.error('Error clearing game state:', error);
          });

        // Clear the players
        playersRef.set(null)
          .then(() => {
            console.log('Players cleared successfully.');
          })
          .catch(error => {
            console.error('Error clearing players:', error);
          });

        // Prompt the player to enter a new username
        const newName = prompt('Enter a new username to rejoin the game:');
        if (newName) {
          playerId = 'player_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
          database.ref('players/' + playerId).set({
            name: newName,
            score: 0
          });
          // Show the game screen again
          document.getElementById('joinScreen').style.display = 'none';
          document.getElementById('mainContent').style.display = 'block';
        } else {
          alert('You must enter a username to rejoin the game.');
          // Show the join screen
          document.getElementById('joinScreen').style.display = 'block';
          document.getElementById('mainContent').style.display = 'none';
        }
      }
    }

    // Add event listener to the reset button
    document.getElementById('resetGameBtn').addEventListener('click', resetGame);


    // Player join logic
    document.getElementById('joinBtn').addEventListener('click', function() {
      const name = document.getElementById('playerName').value.trim();
      if (!name) {
        document.getElementById('joinError').innerText = 'Please enter a name.';
        return;
      }
      // Check if there are already 15 players
      database.ref('players').once('value').then(function(snapshot) {
        const players = snapshot.val() || {};
        if (Object.keys(players).length >= 15) {
          document.getElementById('joinError').innerText = 'Game is full. Maximum 15 players allowed.';
          return;
        }
        // Create a unique player ID and add player to Firebase
        playerId = 'player_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
        database.ref('players/' + playerId).set({
          name: name,
          score: 0
        });
        // Switch from join screen to game screen
        document.getElementById('joinScreen').style.display = 'none';
        document.getElementById('mainContent').style.display = 'block';
      });
    });


    // Reference to the chat messages in the database
    const chatRef = database.ref('chat');

    // Listen for new chat messages
    chatRef.on('child_added', function(snapshot) {
      const message = snapshot.val();
      displayChatMessage(message.name, message.text);
    });

    // Function to display a chat message
    function displayChatMessage(name, text) {
      const chatMessagesDiv = document.getElementById('chatMessages');
      const messageDiv = document.createElement('div');
      messageDiv.textContent = name + ': ' + text;
      chatMessagesDiv.appendChild(messageDiv);
      chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight; // Auto-scroll to the latest message
    }

    // Send chat message
    document.getElementById('sendChatBtn').addEventListener('click', function() {
      sendMessage();
    });

    document.getElementById('chatInput').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        sendMessage();
      }
    });

    function sendMessage() {
      const chatInput = document.getElementById('chatInput');
      const text = chatInput.value.trim();
      if (text !== '') {
        const message = {
          name: playerName, // Ensure playerName is defined globally
          text: text,
          timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        chatRef.push(message);
        chatInput.value = '';
      }
    }


    // Function to handle player removal
    function onPlayerRemoved() {
      alert('The game has been reset. Please rejoin to continue playing.');
      // Clear the stored playerId
      playerId = null;
      // Show the join screen
      document.getElementById('joinScreen').style.display = 'block';
      document.getElementById('mainContent').style.display = 'none';
    }

    // Function to set up listener for player's data removal
    function setupPlayerRemovalListener() {
      if (playerId) {
        const playerRef = database.ref('players/' + playerId);
        playerRef.on('value', function(snapshot) {
          if (!snapshot.exists()) {
            // Player data has been removed
            onPlayerRemoved();
            // Detach the listener after handling
            playerRef.off('value');
          }
        });
      }
    }

    // Call this function after a player joins successfully
    setupPlayerRemovalListener();


  </script>
</body>
</html>
